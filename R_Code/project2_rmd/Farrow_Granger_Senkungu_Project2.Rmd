---
title: "Stats 2 Project 2"
author: "Rick Farrow, Bruce Granger, TQ Senkungu"
date: "12/1/2018"
output:
    html_document:
        keep_md: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load Required Libraries
- Tidyverse 
- Amelia
- Corrplot

```{r Load_Libraries, include=FALSE}
library(tidyverse)
library(Amelia)
library(corrplot)
```

## Load Data

- We are using the Breast Cancer Data from the Wisconsin Diagnostic Breast Cancer (WDBC) dataset and will first load it.

```{r input_data}
wdbc_data <- read.csv("https://raw.githubusercontent.com/tikisen/6372_proj2/master/Data/breast-cancer-wisconsin-data.csv", 
                      sep = ",", 
                      row.names = NULL, 
                      header = TRUE,
                      na.strings = c(""),
                      stringsAsFactors = FALSE)

wdbc_data <- wdbc_data %>% filter(ID !="Sample_code_number")
```

# Bruce's Work Starts Here

## Check for missing values
```{r CheckForMissingValues}
sapply(wdbc_data,function(x) sum(is.na(x)))
```

- The above output identifies there is missing data in each of the attributes, but what is not clear at this point if the missing values are for the same of different IDs.

- The following visualizes where the missing data is occurring:

```{r CheckForMissingValuesViz}
missmap(wdbc_data, main = "Missing values vs observed")
```

- The above visualization shows that the missing feature values are missing from the same ID.  Since each of the respective ID's is missing values for all of the fetures it doesn't make since to impute values, therefore each of the records will be removed from the data set. 

```{r CreateNAFreeDataSet}
wdbc.data <- wdbc_data %>% 
  filter(!is.na(wdbc_data$Uniformity_Cell_Shape))
rm(wdbc_data)
```

- Attributes will be coerced from character to numeric data type. 
- 32 NA will be introduced into the Bare_Nuclei attribute, the median will replace the NA values.
- Add an attribute called CancerState, which is similiar to the Class attribute, the difference is that CancerState uses words to describe the condition, meaning when Class == 2, then "Benign" and when Class == 4, then "Malignanat"

```{r AttributeCoercion}

wdbc.data$ID <- as.integer(wdbc.data$ID)
wdbc.data$Clump_Thickness <- as.integer(wdbc.data$Clump_Thickness)
wdbc.data$Uniformity_Cell_Size <- as.integer(wdbc.data$Uniformity_Cell_Size)
wdbc.data$Uniformity_Cell_Shape <- as.integer(wdbc.data$Uniformity_Cell_Shape)
wdbc.data$Marginal_Adhesion <- as.integer(wdbc.data$Marginal_Adhesion)
wdbc.data$Single_Epithelial_Cell_Size <- as.integer(wdbc.data$Single_Epithelial_Cell_Size)
wdbc.data$Bare_Nuclei <- as.integer(wdbc.data$Bare_Nuclei)
wdbc.data$Bland_Chromatin <- as.integer(wdbc.data$Bland_Chromatin)
wdbc.data$Normal_Nucleoli <- as.integer(wdbc.data$Normal_Nucleoli)
wdbc.data$Mitoses <- as.integer(wdbc.data$Mitoses)
wdbc.data$Class <- as.integer(wdbc.data$Class)

wdbc.data <- wdbc.data %>%
  select(ID = ID, Clump = Clump_Thickness, Cell_Size = Uniformity_Cell_Size, 
         Cell_Shape = Uniformity_Cell_Shape, Adhesion = Marginal_Adhesion,
         Epithelial = Single_Epithelial_Cell_Size, Nuclei = Bare_Nuclei,
         Chromatin = Bland_Chromatin, Nucleoli = Normal_Nucleoli, everything())

wdbc.data %>% select(Nuclei) %>% summary()

wdbc.data$Nuclei <- ifelse(is.na(wdbc.data$Nuclei),
                           median(wdbc.data$Nuclei, na.rm=TRUE), 
                           wdbc.data$Nuclei)

wdbc.data %>% select(Nuclei) %>% summary()

entire.dataset <- wdbc.data %>% 
  mutate(CancerState = case_when(Class == 2 ~ "Benign",
                                 Class == 4 ~ "Malignant"))

entire.dataset$CancerState <- as.factor(entire.dataset$CancerState)
```


## Summary Statistics/Histograms
```{r SummaryStats}
entire.dataset %>% select(c(2:12)) %>% summary() 

# TOTAL COUNT BY CANCER TYPE ####
ggplot(data=entire.dataset, aes(x=CancerState, colour = CancerState)) +
  geom_bar() +
  geom_text(stat='Count', aes(label=..count..), vjust = 10) +
  theme(legend.position = "none") +
  scale_color_manual(values = c("blue", "red")) +
  ggtitle("Total Count by Cancer Type: Blue = Benign; Red = Malignanat") 
  

# PERCENT OF TOTAL BY CANCER TYPE ####
entire.dataset.percent <- entire.dataset %>% 
  count(CancerState) %>% 
  mutate(perc = n / nrow(entire.dataset))

ggplot(data=entire.dataset.percent, aes(x = CancerState, y = perc, colour = CancerState)) +
  geom_bar(stat = "identity") +
  geom_text(stat = "identity", aes(label=round(perc*100,2)), vjust = 10) +
  theme(legend.position = "none") +
  scale_color_manual(values = c("blue", "red")) +
  ggtitle("Percent of Total by Cancer Type: Blue = Benign; Red = Malignanat")
rm(entire.dataset.percent) 
```

## Pairs Plots
- Version 1:
- The objective of the "Pairs Plot" is to create plots based upon paring of variables
- Additionaly, each observation is color coded to simutaleniously see if the observation is "Benign" or "Malignanat" cancer.  
  - Color Coding:
    * Blue = Benign 
    * Red = Malignanat

```{r pairsplot_ver1}
ed.small <- entire.dataset %>% select(-c(1,12))
cols <- character(nrow(ed.small))
cols[] <- "black"
cols[ed.small$Class == 2] <- "blue"
cols[ed.small$Class == 4] <- "red"
pairs(ed.small, col=cols, main = "WDBC Pairs Plot: Blue = Benign; Red = Malignanat")
rm(cols)
```

- Version 2:
- Similar to the first Pairs Plot, however version 2 introduces jitter to the observations and as a result it is easy to see the density of the observations.

```{r pairsplot_ver2}

# the alpha argument in rgb() lets you set the transparency
cols2 = c(rgb(red=0, green=0, blue=255, alpha=50, maxColorValue=255), 
          rgb(red=255, green=0, blue=0, alpha=50, maxColorValue=255))
cols2 = ifelse(ed.small$Class==2, cols2[1], cols2[2])

# here we jitter the data
set.seed(6141)  # this makes the example exactly reproducible
jbreast = apply(ed.small[,1:9], 2, FUN=function(x){ jitter(x, amount=.5) })
jbreast = cbind(jbreast, class=ed.small[,10])  # the class variable is not jittered

#windows()  # to match up the 1st & 2nd sets requires more coding
layout(matrix(1:25, nrow=5, byrow=T))
par(mar=c(.5,.5,.5,.5), oma=c(2,2,2,2))

for(i in 1:5){
   for(j in 6:10){
    
    plot(jbreast[,j], jbreast[,i], col=cols2, pch=16,
         
         axes=F, main="", xlab="", ylab="")
    
    box()
    
    if(j==6 ){ mtext(colnames(jbreast)[i], side=2, cex=.7, line=1) }
    
    if(i==5 ){ mtext(colnames(jbreast)[j], side=1, cex=.7, line=1) }
    
    if(j==10){ axis(side=4, seq(2,10,2), cex.axis=.8) }
    
    if(i==1 ){ axis(side=3, seq(2,10,2), cex.axis=.8) }
    
  }
  
}
rm(list = c("jbreast", "cols2", "i", "j"))

```

## Corrleation Plot
- Positive correlations are displayed in blue and negative correlations in red color.
- Color intensity and the size of the circle are proportional to the correlation coefficients.

```{r CorrelationPlot}
corr <- cor(ed.small)
corrplot(corr, method ="number", type= "upper")
corrplot(corr, method ="circle", type= "upper")
rm(corr)
```

## Histogram
- The histograms are a look at each attribute broken down by CancerState

```{r histogram}
ed.small <- entire.dataset %>% select(-c(1,11))

ed.tall <- ed.small %>%
  gather(-10, key = "Variable", value = "Value") %>% 
  filter(!is.na(CancerState))

ggplot(data = ed.tall, aes(x=Value)) +
  geom_histogram(bins=15) + 
  facet_wrap(Variable ~ CancerState, ncol = 9)
```

## Boxplots
- Boxplot of attributes, color by CancerState

```{r Boxplot}
ed.tall <- ed.small %>% 
  gather(-10, key = "Variable", value = "Value") %>% 
  filter(!is.na(CancerState))

ggplot(ed.tall, aes(x=CancerState, y=Value, fill = CancerState)) + 
  geom_boxplot() +
  facet_wrap(~ Variable) +
  ggtitle("WDBC Boxplot ") + 
  scale_fill_manual(breaks = c("Benign", "Malignanat"), values = c("blue", "red")) +
  theme(legend.position="none")
```

```{r LogisticRegression}
set.seed(12345) #to get repeatable data

wdbc.train <- sample_frac(ed.small, 0.7, replace = FALSE)

train.index <- as.numeric(rownames(wdbc.train))
wdbc.test <- ed.small[-train.index,]

rm(train.index)

# MODEL FITTING
wdbc.glm.fit <- glm(CancerState ~ ., data = wdbc.train, family = binomial(link = "logit"))

summary(wdbc.glm.fit)
```

The following attributes are NOT statistically significant:
* Cell_Size
* Epithelial
  
The following attributes ARE statistically significant:
  * Clump
  * Nuclei
  * Chromatin
  * Adhesion
  * Cell_Shape
  * Mitoses
  
- In this logit model, the response valirable (CancerState) is log odds, a unit increase in Clump increases the odds by 0.6, a unit increase in Nuclei increases the odds by 0.4, and a unit increase in Chromatin increases the odds by 0.5.
- The null deviance (the deviance just for the mean) is 1271 and the residual deviance (the deviance for the model) is 171.
- The difference between the null deviance and the residual deviance shows how the model is doing against the null model (a model with only the intercept). The wider the gap between the null deviance and the residual deviance, the better.
- Analyzing the table we can see the drop in deviance when adding each variable one at a time, with the exception of when adding Nuclei and Chromatin.
- With the addition of Clump significantly reduces the residual deviance and each additional attribute reduces the residual deviance, but in much smaller increments.

```{r GLM_FIT_ANOVA}
anova(wdbc.glm.fit, test = "Chisq")
```
# Bruce's Work Ends Here

# Rick's Work Starts Here

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}

```

# Rick's Work Ends Here

#TQ's Work Starts Here


##Proportions

```{r proportions}
attach(entire.dataset)
#table of counts
ftable(addmargins(table(CancerState, Clump)))
ftable(addmargins(table(CancerState, Cell_Size)))
ftable(addmargins(table(CancerState, Cell_Shape)))
ftable(addmargins(table(CancerState, Adhesion)))
ftable(addmargins(table(CancerState, Epithelial)))
ftable(addmargins(table(CancerState, Nuclei)))
ftable(addmargins(table(CancerState, Chromatin)))
ftable(addmargins(table(CancerState, Nucleoli)))
ftable(addmargins(table(CancerState, Mitoses)))

#in proprtions
prop.table(table(CancerState, Clump),2)
prop.table(table(CancerState, Cell_Size),2)
prop.table(table(CancerState, Cell_Shape),2)
prop.table(table(CancerState, Adhesion),2)
prop.table(table(CancerState, Epithelial),2)
prop.table(table(CancerState, Nuclei),2)
prop.table(table(CancerState, Chromatin),2)
prop.table(table(CancerState, Nucleoli),2)
prop.table(table(CancerState, Mitoses),2)

#vizualize 
plot(CancerState~Clump,col=c("red","blue"))
plot(CancerState~Cell_Shape,col=c("red","blue"))
plot(CancerState~Cell_Size,col=c("red","blue"))
plot(CancerState~Adhesion,col=c("red","blue"))
plot(CancerState~Epithelial,col=c("red","blue"))
plot(CancerState~Nuclei,col=c("red","blue"))
plot(CancerState~Chromatin,col=c("red","blue"))
plot(CancerState~Nucleoli,col=c("red","blue"))
plot(CancerState~Mitoses,col=c("red","blue"))

```

## PCA

```{r PCA}
pc.result<-prcomp(entire.dataset[,2:11],scale.=TRUE)
pc.scores<-pc.result$x
pc.scores<-data.frame(pc.scores)
pc.scores$Class<-entire.dataset$Class

#Scree plot
eigenvals<-(pc.result$sdev)^2
plot(1:10,eigenvals/sum(eigenvals),type="l",main="Scree Plot PC's",ylab="Prop. Var. Explained",ylim=c(0,1))
cumulative.prop<-cumsum(eigenvals/sum(eigenvals))
lines(1:10,cumulative.prop,lty=2)


#Use ggplot2 to plot the first few pc's
ggplot(data = pc.scores, aes(x = PC1, y = PC2)) +
  geom_point(aes(col=Class), size=1)+
  ggtitle("PCA of Cancer Status")

ggplot(data = pc.scores, aes(x = PC2, y = PC3)) +
  geom_point(aes(col=Class), size=1)+
  ggtitle("PCA of Cancer Status")

ggplot(data = pc.scores, aes(x = PC1, y = PC3)) +
  geom_point(aes(col=Class), size=1)+
  ggtitle("PCA of Cancer Status")
```
## Separation

PC1 vs PC2 and PC1 vs PC3 show good separation so some variable is a good predictor of cancer status.


## LDA & QDA

```{r LDA_QDA}
library(ROCR)
library(MASS)
mylda<- lda(Class ~ Clump+Cell_Size+Cell_Shape+Adhesion+Epithelial+Nuclei+Chromatin+Nucleoli+Mitoses, data = entire.dataset)
myqda<- qda(Class ~ Clump+Cell_Size+Cell_Shape+Adhesion+Epithelial+Nuclei+Chromatin+Nucleoli+Mitoses, data = entire.dataset)

#confusion matrix
set.seed(2134)
index<-sample(1:385,250,replace=FALSE)
test.entire.dataset<-entire.dataset[-index,]
prd<-predict(mylda, newdata = test.entire.dataset)$class
table(prd,test.entire.dataset$Class)
```


## Stepwise Regression

```{r stepwise}
#?lm

full.model <- lm (Class ~., data = entire.dataset)
```

## LDA

```{r LDA}
entire.dataset.continuous <- entire.dataset[, c(2:11)]
pairs(entire.dataset.continuous[,1:10])

```


#TQ's Work Ends Here